# -*- coding: utf-8 -*-
"""goochoo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vGyHCnMrA8h0IpuP_hdsAeDVCaEmM1Hj
"""

from google.colab import drive
drive.mount('/content/drive')


from numpy import genfromtxt
import numpy as np
import pandas as pd 
from sklearn.metrics import recall_score, precision_score, f1_score, accuracy_score, confusion_matrix
from keras.utils import to_categorical
from sklearn.preprocessing import OneHotEncoder
from numpy import loadtxt
import statistics
import math
import csv
import ogr, os
import shapely
from shapely.geometry import *
from shapely.geometry import Polygon
import time
import matplotlib.pyplot as plt
from PIL import Image
from shapely.geometry import LineString
import seaborn as sns
from scipy import stats
from osgeo import ogr
from PIL import Image
import numpy as np



#  ======================== data for deep ======================================
idtype= []

with open("file_ID.csv", 'r') as csvfile: 
    reader = csv.DictReader(csvfile)
    for row in reader:
            idtype.append(row)
csvfile.close()



data=[]
with open("dataxy.csv", 'r') as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
            data.append(row)
csvfile.close()
#========================= make directory ======================================
saveFolder= './img1/'
if not os.path.exists(saveFolder_trajectory):
    # Create a new directory because it does not exist 
    os.makedirs(saveFolder)

counter=0 
TH=180
image_TH=190


data_new=[]
for i in range(0,len(data)):
  p0row=data[i]
  if p0row['sensor']!='m052' and p0row['sensor'] != 'd017' and  p0row['sensor']!='d018'  and  p0row['sensor']!='i001'  and  p0row['sensor']!='i002'  and  p0row['sensor']!='i003'  and  p0row['sensor']!='i004' and  p0row['sensor']!='i005' and  p0row['sensor']!='i006' and p0row['sensor']!='i007' and  p0row['sensor']!='i008' and  p0row['sensor']!='i009' and  p0row['sensor']!='i010' :
    data_new.append(p0row)


data_source=data_new


import time

_start_time = time.time()

def tic():
    global _start_time 
    _start_time = time.time()

def tac():
    t_sec = round(time.time() - _start_time)
    (t_min, t_sec) = divmod(t_sec,60)
    (t_hour,t_min) = divmod(t_min,60) 
    print('Time passed: {}hour:{}min:{}sec'.format(t_hour,t_min,t_sec))




tic()
section_all=[]
section_all_2=[]
section_start_end=[]
section_1=[]
section_2=[]
count_num=1
all_name=[]
section_len_max=[]
section_len_min=[]
section_len_all=[]
for row in idtype:
  print('person number'+str(count_num))
  id_num=float(row.get('id'))
  id_num_str=row.get('id')

  id_type=float(row.get('type'))


  temp=[]
  for j in range(0,len(data_source)):
    p0row=data_source[j]
    if int(p0row['patient'])==id_num:
      temp.append(p0row)

  data=temp
  
  
  id_NUM=id_num_str
  type_NUM=id_type

  #==============read csv file as input(act matrix)==============================
  # ========================== save time in seconds in time_s ====================
  for i in range (0,len(data)):
    point=data[i:i+1]
    for p1Row in point:
      time_1 = p1Row.get('time')
      t_hour_1=float(time_1[0:2])
      t_min_1=float(time_1[3:5])
      t_sec_1=float(time_1[6:10])
      time_sec_1=t_hour_1*3600+t_min_1*60+t_sec_1 
    p1Row['time_s']=time_sec_1

  #=====================================================================================
  # find sensor with high speed for person
  def high_speed(data):
    x=[]
    y=[]
    index=[]
    data_temp=[]
    for i in range(0,len(data)):
      g=data[i]
      x_temp=g['X']
      y_temp=g['Y']
      x.append(x_temp)
      y.append(y_temp)
      index.append(i)
      
    distance=[]
    time=[]
    speed=[]
    speed.append(0)
    for k in range(0,len(x)-1):
      g1= data[k]
      g2=data[k+1]
      x1 =float(g1['X'])
      y1= float(g1['Y'])
      x2 =float(g2['X'])
      y2= float(g2['Y'])
      time1=float(g1['time_s'])
      time2=float(g2['time_s'])

      dist_temp=(x2-x1)**2+(y2-y1)**2
      dist=math.sqrt(dist_temp)
      time_tmep=time2-time1
      distance.append(dist)
      time.append(time_tmep)

      if distance[k]==0 and time[k]==0:
        speed_temp=0
      elif distance[k]!=0 and time[k]==0:
          speed_temp=0
      else:
        speed_temp=distance[k]/time[k]
      speed.append(speed_temp)

    for L in range(0,len(speed)):
      if speed[L]==np.inf:
        speed[L][0]==0
      
    #define threshold for speed more than 15m/s
    for tt in range(0,len(speed)):
      gg=data[tt]
      if speed[tt]>=15:
        gg['speed']=speed[tt]
      else: 
        gg['speed']=speed[tt]
        data_temp.append(gg)


    x=[];
    y=[];
    index=[]
    data=data_temp
    return data 
  #=====================================================================================
  # ==================== delete by distance more than 5 meter ====================
  def delete_by_dist(data):
    count=0
    data_temp=[]
    data_temp.append(data[0])
    x1=float(data[count]['X'])
    y1=float(data[count]['Y'])

    x2=float(data[count+1]['X'])
    y2=float(data[count+1]['Y'])
    while count< len(data)-2:

      dist=math.sqrt((x2-x1)**2+(y2-y1)**2)
      if dist<=5:
        data_temp.append(data[count+1])
        count=count+1
        x1=float(data[count]['X'])
        y1=float(data[count]['Y'])

        x2=float(data[count+1]['X'])
        y2=float(data[count+1]['Y'])
      else:
        count=count+1
        x2=float(data[count+1]['X'])
        y2=float(data[count+1]['Y'])

    data=data_temp 
    return data 

#==============================================================================
  size_delete_speed=1
  size_delete_dist=0
  while size_delete_dist!=size_delete_speed:
    data=delete_by_dist(data)
    size_delete_dist=len(data)

    data=high_speed(data)
    size_delete_speed=len(data)    
#===============================================================================
  def delete_bytime(data):
    data_temp=[]
    data_temp.append(data[0])


    for i in range (0,len(data)-1):
      point_1=data[i:i+1]
      for p1Row in point_1:
        time_1 = p1Row.get('time_s')

      point_2=data[i+1:i+2]
      for p2Row in point_2:
        time_2 = p2Row.get('time_s')
        
      time_diff=time_2-time_1



      if time_diff >0:
        data_temp.append(data[i+1:i+2][0])
    return data_temp
#===============================================================================
  len_1=0
  len_2=1
  while len_1!=len_2:
    len_1=len(data)
    data=delete_bytime(data)
    len_2=len(data)


#=======================================================================================
#=======================================================================================
#=======================================================================================
# ====================== deltax and delatay calculation=========================

  for i in range(0,len(data)-1):
    g1= data[i]
    g2=data[i+1]


    x1 =float(g1['X'])
    y1= float(g1['Y'])

    x2 =float(g2['X'])
    y2= float(g2['Y'])


    g1['deltax']=x2-x1
    g1['deltay']=y2-y1


  # ===========================define section ====================================
  #-------------------- define episode for every 60 seconds ---------------------
  count=1
  section_1=[]
  section_2=[]
  section_1.append(0)
  speed_all=[]

  for i in range(len(data)):
    data_point_1=data[i:i+1]
    data_point_2=data[i+1:i+2]

    for p1Row in data_point_1:
      time_1 = p1Row.get('time')
      t_hour_1=float(time_1[0:2])
      t_min_1=float(time_1[3:5])
      t_sec_1=float(time_1[6:10])
      time_sec_1=t_hour_1*3600+t_min_1*60+t_sec_1 

    for p2Row in data_point_2:
      time_2 = p2Row.get('time')
      t_hour_2=float(time_2[0:2])
      t_min_2=float(time_2[3:5])
      t_sec_2=float(time_2[6:10])
      time_sec_2=t_hour_2*3600+t_min_2*60+t_sec_2
    
    time_diff=time_sec_2-time_sec_1


    if time_diff>TH:

      section_1.append(i+1)
      section_2.append(i)
      count=count+1
      
    elif time_diff<=TH  :
      p1Row['section']=count



        
  section_2.append(len(data)-1)



  # -----------------delete section  which start and end are  equal---------


  section_1_temp=[]
  section_2_temp=[]
  for i in range(0, len(section_1)):
    if section_1[i]!=section_2[i]:
      section_1_temp.append(section_1[i])
      section_2_temp.append(section_2[i])

  section_1=section_1_temp
  section_2=section_2_temp
  print(len(section_1))


  # delete section with less than 3 step length

  section_1_temp=[]
  section_2_temp=[]
  for i in range(0, len(section_1)):
    if section_2[i]-section_1[i]> 3:
      section_1_temp.append(section_1[i])
      section_2_temp.append(section_2[i])

  section_1=section_1_temp
  section_2=section_2_temp
  print(len(section_1))  


  for i in range(0,len(data)-2):
  #------------------------------------- calculate angle  ---------------------------------------------
    data_point_1=data[i:i+1]
    data_point_2=data[i+1:i+2]
    data_point_3=data[i+2:i+3]
    for p1Row in data_point_1:
      x1=float(p1Row.get('X'))
      y1=float(p1Row.get('Y'))
      time_1=p1Row.get('time_s')

    for p2Row in data_point_2:
      x2=float(p2Row.get('X'))
      y2=float(p2Row.get('Y'))
      time_2=p2Row.get('time_s')

    for p3Row in data_point_3:
      x3=float(p3Row.get('X'))
      y3=float(p3Row.get('Y'))
      time_3=p3Row.get('time_s')


    # ---------------------SPEED AND ACCELERATION --------------------------------
    delta_x_first=x2-x1
    delta_y_first=y2-y1

    delta_x_second=x3-x2
    delta_y_second=y3-y2
    
    D_first=math.sqrt(delta_x_first**2+delta_y_first**2)
    D_second=math.sqrt(delta_x_second**2+delta_y_second**2)

    time_diff_fist=time_2-time_1
    time_diff_second=time_3-time_2
    
    speed_first=D_first/time_diff_fist
    speed_second=D_second/time_diff_second

    speed_all.append(speed_first)

    acceleration=(speed_second-speed_first)/time_diff_fist
    



    #------------------------------- save in p ----------------------------------
    p1Row['delta_x']=delta_x_first
    p1Row['delta_y']=delta_y_first
    p1Row['time_diff']=time_diff_fist
    p1Row['Dist']=D_first



 #================================================================================
  # @------------------ time in section ------------------------------------------
  sec_time=[]

  for i in range (0,len(section_1)):
    P_start=data[section_1[i]:section_1[i]+1]
    P_end=data[section_2[i]:section_2[i]+1]
    for p1row in P_start:
      time_1=p1row.get('time_s')

    for p2row in P_end:
      time_2=p2row.get('time_s')

    time_diff=time_2-time_1

    sec_time.append(time_diff)





  #=============================================================================================================
  #-------------- calculate distance/ angle/time_diff/ jerk/ acc/ steatness in section--------------------------
  #=============================================================================================================

  dist_sum=0
  sec_dist=[]

  for i in range (0,len(section_1)):
    P_start=section_1[i]
    P_end=section_2[i]
    if i==len(section_1)-1:
      P_end=P_end-3
    for j in range(P_start,P_end):
      Point_temp_1=data[j:j+1]
      for p1row in Point_temp_1:
        dist=float(p1row.get('Dist'))

      dist_sum=dist_sum+dist
      

    sec_dist.append(dist_sum)
    dist_sum=0


  # ---------------------- id and type -------------------------------------------
  sec_id=[]
  sec_type=[]
  for i in range(0,len(section_1)):
    sec_id.append(int(id_NUM))
    sec_type.append(type_NUM)


# -------------------------------- start and end time in section --------------
  for i in range(0,len(section_1)):
    a=[]
    a1=data[section_1[i]].get('time')
    a2=data[section_2[i]].get('time')
    a=[a1,a2]
    section_start_end.append(a)


  
  a=[]
  for i in range(0,len(section_1)):
    a=[section_1[i],section_2[i], sec_time[i],sec_dist[i],sec_id[i],sec_type [i]]

    section_all.append(a)
    
  

  np.savetxt("section_all.csv", section_all, delimiter=",")  


  with open("section_start_end.txt", "w") as f:
    for p1Row in section_start_end:
        f.write(p1Row[0] + "," + p1Row[1] + "\n")


  section_1_new=[]
  section_2_new=[]
  for i in range(0,len(section_1)):
    section_1_temp=section_1[i]
    section_2_temp=section_2[i]
    if sec_dist[i]!=0:
      section_1_new.append(section_1_temp)
      section_2_new.append(section_2_temp)
  
  section_1=section_1_new
  section_2=section_2_new

  # # ================ delete consecuative repative sensors=======================
  section_len=[]
  for iiii in range(0,len(section_1)): 
    SENSOR_LIST=[]
    for j in range(section_1[iiii],section_2[iiii]+1):
      sensor=data[j]['Sensor_Name']
      SENSOR_LIST.append(sensor)
    section_len.append(len(SENSOR_LIST))
    
    sensor_all=[]
    sensor_all.append(SENSOR_LIST[0])
    s1=SENSOR_LIST[0]
    list_count=1

    while  list_count< len(SENSOR_LIST):
      s2=SENSOR_LIST[list_count]
      if s1==s2:
        list_count=list_count+1
      else: 
        sensor_all.append(s2)
        s1=s2
        list_count=list_count+1

    section_len.append(len(sensor_all))
    section_len_all.append(len(sensor_all))



  section_len_min.append(min(section_len))
  section_len_max.append(max(section_len))


# ================================ create plot ================================
# ========================== create x and y file for every section ============
# =============================================================================




  count_num=count_num+1

section_len_min_final=min(section_len_min)
section_len_max_final=max(section_len_max)
tac()



tic()

section_all=[]
section_all_2=[]
section_start_end=[]
section_1=[]
section_2=[]
count_num=1
all_name=[]
SENSOR_X_FINAL=[]
SENSOR_Y_FINAL=[]
for row in idtype:
  print('person number'+str(count_num))
  id_num=float(row.get('id'))
  id_num_str=row.get('id')

  id_type=float(row.get('type'))


  temp=[]
  for j in range(0,len(data_source)):
    p0row=data_source[j]
    if int(p0row['patient'])==id_num:
      temp.append(p0row)

  data=temp
  
  
  id_NUM=id_num_str
  type_NUM=id_type

  #==============read csv file as input(act matrix)==============================
  # ========================== save time in seconds in time_s ====================
  for i in range (0,len(data)):
    point=data[i:i+1]
    for p1Row in point:
      time_1 = p1Row.get('time')
      t_hour_1=float(time_1[0:2])
      t_min_1=float(time_1[3:5])
      t_sec_1=float(time_1[6:10])
      time_sec_1=t_hour_1*3600+t_min_1*60+t_sec_1 
    p1Row['time_s']=time_sec_1

  #=====================================================================================
  # find sensor with high speed for person
  def high_speed(data):
    x=[]
    y=[]
    index=[]
    data_temp=[]
    for i in range(0,len(data)):
      g=data[i]
      x_temp=g['X']
      y_temp=g['Y']
      x.append(x_temp)
      y.append(y_temp)
      index.append(i)
      
    distance=[]
    time=[]
    speed=[]
    speed.append(0)
    for k in range(0,len(x)-1):
      g1= data[k]
      g2=data[k+1]
      x1 =float(g1['X'])
      y1= float(g1['Y'])
      x2 =float(g2['X'])
      y2= float(g2['Y'])
      time1=float(g1['time_s'])
      time2=float(g2['time_s'])

      dist_temp=(x2-x1)**2+(y2-y1)**2
      dist=math.sqrt(dist_temp)
      time_tmep=time2-time1
      distance.append(dist)
      time.append(time_tmep)

      if distance[k]==0 and time[k]==0:
        speed_temp=0
      elif distance[k]!=0 and time[k]==0:
          speed_temp=0
      else:
        speed_temp=distance[k]/time[k]
      speed.append(speed_temp)

    for L in range(0,len(speed)):
      if speed[L]==np.inf:
        speed[L][0]==0
      
    #define threshold for speed more than 15m/s
    for tt in range(0,len(speed)):
      gg=data[tt]
      if speed[tt]>=15:
        gg['speed']=speed[tt]
      else: 
        gg['speed']=speed[tt]
        data_temp.append(gg)


    x=[];
    y=[];
    index=[]
    data=data_temp
    return data 
  #=====================================================================================
  # ==================== delete by distance more than 5 meter ====================
  def delete_by_dist(data):
    count=0
    data_temp=[]
    data_temp.append(data[0])
    x1=float(data[count]['X'])
    y1=float(data[count]['Y'])

    x2=float(data[count+1]['X'])
    y2=float(data[count+1]['Y'])
    while count< len(data)-2:

      dist=math.sqrt((x2-x1)**2+(y2-y1)**2)
      if dist<=5:
        data_temp.append(data[count+1])
        count=count+1
        x1=float(data[count]['X'])
        y1=float(data[count]['Y'])

        x2=float(data[count+1]['X'])
        y2=float(data[count+1]['Y'])
      else:
        count=count+1
        x2=float(data[count+1]['X'])
        y2=float(data[count+1]['Y'])

    data=data_temp 
    return data 

#==============================================================================
  size_delete_speed=1
  size_delete_dist=0
  while size_delete_dist!=size_delete_speed:
    data=delete_by_dist(data)
    size_delete_dist=len(data)

    data=high_speed(data)
    size_delete_speed=len(data)    
#===============================================================================
  def delete_bytime(data):
    data_temp=[]
    data_temp.append(data[0])


    for i in range (0,len(data)-1):
      point_1=data[i:i+1]
      for p1Row in point_1:
        time_1 = p1Row.get('time_s')

      point_2=data[i+1:i+2]
      for p2Row in point_2:
        time_2 = p2Row.get('time_s')
        
      time_diff=time_2-time_1



      if time_diff >0:
        data_temp.append(data[i+1:i+2][0])
    return data_temp
#===============================================================================
  len_1=0
  len_2=1
  while len_1!=len_2:
    len_1=len(data)
    data=delete_bytime(data)
    len_2=len(data)


#=======================================================================================
#=======================================================================================
#=======================================================================================
# ====================== deltax and delatay calculation=========================

  for i in range(0,len(data)-1):
    g1= data[i]
    g2=data[i+1]


    x1 =float(g1['X'])
    y1= float(g1['Y'])

    x2 =float(g2['X'])
    y2= float(g2['Y'])


    g1['deltax']=x2-x1
    g1['deltay']=y2-y1


  # ===========================define section ====================================
  #-------------------- define episode for every 60 seconds ---------------------
  count=1
  section_1=[]
  section_2=[]
  section_1.append(0)
  speed_all=[]

  for i in range(len(data)):
    data_point_1=data[i:i+1]
    data_point_2=data[i+1:i+2]

    for p1Row in data_point_1:
      time_1 = p1Row.get('time')
      t_hour_1=float(time_1[0:2])
      t_min_1=float(time_1[3:5])
      t_sec_1=float(time_1[6:10])
      time_sec_1=t_hour_1*3600+t_min_1*60+t_sec_1 

    for p2Row in data_point_2:
      time_2 = p2Row.get('time')
      t_hour_2=float(time_2[0:2])
      t_min_2=float(time_2[3:5])
      t_sec_2=float(time_2[6:10])
      time_sec_2=t_hour_2*3600+t_min_2*60+t_sec_2
    
    time_diff=time_sec_2-time_sec_1


    if time_diff>TH:

      section_1.append(i+1)
      section_2.append(i)
      count=count+1
      
    elif time_diff<=TH  :
      p1Row['section']=count



        
  section_2.append(len(data)-1)


  # -----------------delete section  which start and end are  equal---------


  section_1_temp=[]
  section_2_temp=[]
  for i in range(0, len(section_1)):
    if section_1[i]!=section_2[i]:
      section_1_temp.append(section_1[i])
      section_2_temp.append(section_2[i])

  section_1=section_1_temp
  section_2=section_2_temp
  print(len(section_1))




  # delete section with less than 3 step length

  section_1_temp=[]
  section_2_temp=[]
  for i in range(0, len(section_1)):
    if section_2[i]-section_1[i]> 3:
      section_1_temp.append(section_1[i])
      section_2_temp.append(section_2[i])

  section_1=section_1_temp
  section_2=section_2_temp
  print(len(section_1))  


  for i in range(0,len(data)-2):
  #------------------------------------- calculate angle  ---------------------------------------------
    data_point_1=data[i:i+1]
    data_point_2=data[i+1:i+2]
    data_point_3=data[i+2:i+3]
    for p1Row in data_point_1:
      x1=float(p1Row.get('X'))
      y1=float(p1Row.get('Y'))
      time_1=p1Row.get('time_s')

    for p2Row in data_point_2:
      x2=float(p2Row.get('X'))
      y2=float(p2Row.get('Y'))
      time_2=p2Row.get('time_s')

    for p3Row in data_point_3:
      x3=float(p3Row.get('X'))
      y3=float(p3Row.get('Y'))
      time_3=p3Row.get('time_s')


    # ---------------------SPEED AND ACCELERATION --------------------------------
    delta_x_first=x2-x1
    delta_y_first=y2-y1

    delta_x_second=x3-x2
    delta_y_second=y3-y2
    
    D_first=math.sqrt(delta_x_first**2+delta_y_first**2)
    D_second=math.sqrt(delta_x_second**2+delta_y_second**2)

    time_diff_fist=time_2-time_1
    time_diff_second=time_3-time_2
    
    speed_first=D_first/time_diff_fist
    speed_second=D_second/time_diff_second

    speed_all.append(speed_first)

    acceleration=(speed_second-speed_first)/time_diff_fist
    



    #------------------------------- save in p ----------------------------------
    p1Row['delta_x']=delta_x_first
    p1Row['delta_y']=delta_y_first
    p1Row['time_diff']=time_diff_fist
    p1Row['Dist']=D_first



 #================================================================================
  # @------------------ time in section ------------------------------------------
  sec_time=[]

  for i in range (0,len(section_1)):
    P_start=data[section_1[i]:section_1[i]+1]
    P_end=data[section_2[i]:section_2[i]+1]
    for p1row in P_start:
      time_1=p1row.get('time_s')

    for p2row in P_end:
      time_2=p2row.get('time_s')

    time_diff=time_2-time_1

    sec_time.append(time_diff)





  #=============================================================================================================
  #-------------- calculate distance/ angle/time_diff/ jerk/ acc/ steatness in section--------------------------
  #=============================================================================================================

  dist_sum=0
  sec_dist=[]

  for i in range (0,len(section_1)):
    P_start=section_1[i]
    P_end=section_2[i]
    if i==len(section_1)-1:
      P_end=P_end-3
    for j in range(P_start,P_end):
      Point_temp_1=data[j:j+1]
      for p1row in Point_temp_1:
        dist=float(p1row.get('Dist'))

      dist_sum=dist_sum+dist
      

    sec_dist.append(dist_sum)
    dist_sum=0


  # ---------------------- id and type -------------------------------------------
  sec_id=[]
  sec_type=[]
  for i in range(0,len(section_1)):
    sec_id.append(int(id_NUM))
    sec_type.append(type_NUM)


# -------------------------------- start and end time in section --------------
  for i in range(0,len(section_1)):
    a=[]
    a1=data[section_1[i]].get('time')
    a2=data[section_2[i]].get('time')
    a=[a1,a2]
    section_start_end.append(a)


  
  a=[]
  for i in range(0,len(section_1)):
    a=[section_1[i],section_2[i], sec_time[i],sec_dist[i],sec_id[i],sec_type [i]]

    section_all.append(a)
    
  

  np.savetxt("section_all.csv", section_all, delimiter=",")  


  with open("section_start_end.txt", "w") as f:
    for p1Row in section_start_end:
        f.write(p1Row[0] + "," + p1Row[1] + "\n")


  section_1_new=[]
  section_2_new=[]
  for i in range(0,len(section_1)):
    section_1_temp=section_1[i]
    section_2_temp=section_2[i]
    if sec_dist[i]!=0:
      section_1_new.append(section_1_temp)
      section_2_new.append(section_2_temp)
  
  section_1=section_1_new
  section_2=section_2_new


# ================================ create plot ================================
# ========================== create x and y file for every section ============
# =============================================================================

  for iiii in range(0,len(section_1)): 
    
    SENSOR_LIST=[]
    SENSOR_Y=[counter,sec_type[iiii],sec_id[iiii]]
    for j in range(section_1[iiii],section_2[iiii]+1):
      sensor=data[j]['Sensor_Name']
      SENSOR_LIST.append(sensor)


    sensor_all=[]
    sensor_all.append(SENSOR_LIST[0])
    s1=SENSOR_LIST[0]
    list_count=1

    while  list_count< len(SENSOR_LIST):
      s2=SENSOR_LIST[list_count]
      if s1==s2:
        list_count=list_count+1
      else: 
        sensor_all.append(s2)
        s1=s2
        list_count=list_count+1

    SENSOR_LIST=sensor_all
    if len(SENSOR_LIST)>image_TH:
      SENSOR_LIST=SENSOR_LIST[0:image_TH]

    results = np.zeros((67, image_TH))
    # results = np.zeros((67, section_len_max_final))
    
    for i in range (0,len(SENSOR_LIST)):
      sensor=SENSOR_LIST[i]
      if sensor== 'm051':  results[0, i] = 1.;
      elif sensor== 'd011': results[1, i] = 1.;
      elif sensor=='m018':  results[2, i] = 1.;
      elif sensor=='d015':  results[3, i] = 1.;
      elif sensor=='d014':  results[4, i] = 1.;
      elif sensor=='d007':  results[5, i] = 1.;
      elif sensor=='d016':  results[6, i] = 1.;
      elif sensor=='m017':  results[7, i] = 1.;
      elif sensor== 'm016':  results[8, i] = 1.;
      elif sensor== 'm015':  results[9, i] = 1.;
      elif sensor== 'm014':  results[10, i] = 1.;
      elif sensor== 'm013': results[11, i] = 1.;
      elif sensor== 'm012': results[12, i] = 1.;
      elif sensor== 'd002': results[13, i] = 1.;
      elif sensor== 'm011':results[14, i] = 1.;
      elif sensor== 'm010':results[15, i] = 1.;
      elif sensor== 'm009':results[16, i] = 1.;
      elif sensor== 'm008': results[17, i] = 1.;
      elif sensor== 'm005': results[18, i] = 1.;
      elif sensor== 'm004': results[19, i] = 1.;
      elif sensor== 'm006': results[20, i] = 1.;
      elif sensor== 'm003': results[21, i] = 1.;
      elif sensor== 'm002': results[22, i] = 1.;
      elif sensor== 'm007': results[23, i] = 1.;
      elif sensor== 'd013': results[24, i] = 1.;
      elif sensor== 'm001': results[25, i] = 1.;
      elif sensor== 'm023': results[26, i] = 1.;
      elif sensor== 'm022': results[27, i] = 1.;
      elif sensor== 'm021': results[28, i] = 1.;
      elif sensor== 'm020': results[29, i] = 1.;
      elif sensor== 'm019': results[30, i] = 1.;
      elif sensor== 'd010': results[31, i] = 1.;
      elif sensor== 'd009': results[32, i] = 1.;
      elif sensor== 'd008': results[33, i] = 1.;
      elif sensor== 'd012': results[34, i] = 1.;
      elif sensor== 'm024': results[35, i] = 1.;
      elif sensor== 'd001': results[36, i] = 1.;
      elif sensor== 'm025': results[37, i] = 1.;
      elif sensor== 'm026': results[38, i] = 1.;
      elif sensor== 'm027': results[39, i] = 1.;
      elif sensor== 'm028': results[40, i] = 1.;
      elif sensor== 'm029': results[41, i] = 1.;
      elif sensor== 'd003': results[42, i] = 1.;
      elif sensor== 'm030': results[43, i] = 1.;
      elif sensor== 'm036': results[44, i] = 1.;
      elif sensor== 'm035': results[45, i] = 1.;
      elif sensor== 'm034': results[46, i] = 1.;
      elif sensor== 'm033': results[47, i] = 1.;
      elif sensor== 'm032': results[48, i] = 1.;
      elif sensor== 'm031': results[49, i] = 1.;
      elif sensor== 'm037': results[50, i] = 1.;
      elif sensor== 'd005': results[51, i] = 1.;
      elif sensor==  'm038': results[52, i] = 1.;
      elif sensor== 'm039': results[53, i] = 1.;
      elif sensor== 'm040': results[54, i] = 1.;
      elif sensor== 'd006': results[55, i] = 1.;
      elif sensor== 'm041': results[56, i] = 1.;
      elif sensor== 'm042': results[57, i] = 1.;
      elif sensor== 'm043': results[58, i] = 1.;
      elif sensor== 'd004': results[59, i] = 1.;
      elif sensor== 'm044': results[60, i] = 1.;
      elif sensor== 'm050': results[61, i] = 1.;
      elif sensor== 'm049': results[62, i] = 1.;
      elif sensor== 'm048': results[63, i] = 1.;
      elif sensor== 'm047': results[64, i] = 1.;
      elif sensor== 'm046': results[65, i] = 1.;
      elif sensor== 'm045': results[66, i] = 1.;


    SENSOR_X_FINAL.append(results)
    Image.fromarray((results * 255).astype('uint8'), mode='L').save(saveFolder + str(counter) + '.png')
    SENSOR_Y_FINAL.append(SENSOR_Y)

    counter=counter+1

  count_num=count_num+1

tac()

# save output in csv
np.savetxt("SENSOR_Y_FINAL.csv", SENSOR_Y_FINAL, delimiter=",") 
!zip -r /content/img1.zip /content/img1


np.savetxt("section_len_min.csv", section_len_min, delimiter=",") 
np.savetxt("section_len_max.csv", section_len_max, delimiter=",")